# Design Document - Magic 8 Ball Server and Client

Cooper Vandiver\
CS 440 - Program #3\
March 3, 2023

This document describes the design for a server that acts as a magic 8 ball,
along with a client program that connects to the server to get a response to
a yes or no question. 

# Program Requirements
The program simulates a "Magic 8 Ball." The server acts as the ball,
generating a random response to a yes or no question following a sequence of
valid messages (i.e., adhering to the specified protocol) between the client
and server. Both the server and client send messages consisting of at least
4 bytes, all of which are ASCII characters. The first two bytes in each
message specify the message type For this program, the valid types are "10",
"20", "30", and "40". "50" is used to signify the end of communication due to
an error that arises when a message violates the specified magic 8 ball
protocol. The next two bytes contain the length of the payload, which must 
be in the range 0-32, inclusive. The following bytes of the message contain
the payload, whose length is previously specified; the payload does not need
to contain either a null-terminating or newline character. If either the
server or client receives a message of type "50", an error has occurred and 
communication must be ceased.

## Server
The server is required to answer the initial request (a message with type
"10"). This message serves as a greeting, and the server will then respond
with a greeting to the client, this time with the message having a type of
"20". The next message received, with a type of "30" is the client's question.
Following this message being received, the server should send one final
message, this time with a type of "40", which has a payload that contains the
pseudo-randomly generated answer to the client's question. For both messages
received from the client, the payload of said message does not need to be
evaluated; the message does, however, need to be checked for validity. If
any message is improperly formed, the server should respond with an error
message with a type of "50". The server will continue to listen to and respond
to client connections until SIGINT is raised.

## Client
The client program is required to initiate connection to the server and send
the first message with a type of "10". After receiving a response from the
server, this time with a type of "20", the client should respond with a
message containing a question, this time with a type of "30". The next message
received from the server, with a type of "40" will be the pseudo-randomly
generated response to the previously sent question. If, at any point, a
message is sent that does not conform to the specified magic 8 ball protocol,
the client should respond with some message of type "50", which signifies
an error and will terminate the connection.

# Program Inputs
Both the server and client programs will receive messages from the other
program, and each message must be verified for validity as specified in the 
magic 8 ball protocol.

## Server
The server will receive two messages from the client, one of type "10" and 
one of type "30". The payloads of both messages can be ignored aside from 
checking for sanity. If the server receives a message of type "50" at any
point, an error has occurred, and communication must be ceased with the
currently connected client.

## Client
The client will receive two messages from the server, one of type "20" and
another of type "40". The contents of type "20" can be ignored, although it
must still be checked for validity. The latter message, however, contains the
response to the question posed by the client. As such, the contents of the
payload need to be parsed out and printed to stdout. If a message is ever
received that is of type "50", the connection to the server must be broken,
and the program can exit gracefully.

# Program Outputs

## Server
The server will send two messages to the client: one, of type "20", containing
a greeting or some other text, and another of type "40", the pseudo-randomly
generated response to the question posed by the client.

## Client
The client will send two messages to the server: one, of type "10", containing
a greeting or some other random text, and another of type "30", containing the
question that the user wants to be answered by the magic 8 ball. The client,
upon receiving a valid answer to its question, needs to parse the payload from
the message and print it to stdout where it can be read by the end user.

# Test Plan
Due to the tightly-coupled nature of the two programs (i.e., the client is
developed to exclusively send and receive messages to some server that
conforms to the magic 8 ball protocol), the server will be developed first,
and will be tested with a well-tested application (netcat) to verify that it
works. Following verification that the server is working as expected, the
client can be developed and then tested using the server.

## Server
As stated above, the server will be tested using the command-
line application "netcat". Using this tool in lieu of trying
to developed a client at the same rate as the server will allow
for bugs to be better localized and resolved. The table below
shows an example command, along with the extracted message and
response that both adhere to the magic 8 ball protocol.
| Command | Question | Answer |
| ------- | -------- | ------ |
| echo "3023Will I pass this course?" \| nc localhost 11044 | "3024Will I pass this class?" | "4013Very doubtful" |
| echo "3026Is it going to rain today?" \| nc localhost 11044 | "3026Is it going to rain today?" | "4018You may rely on it" |
| echo "3026Should I skip class today?" \| nc localhost 11044 | "3026Should I skip class today?" | "4016As I see it, yes" |
| echo "3036Will I get a good job after college?" \| nc localhost 11044 | "3036Will I get a good job after college?" | "5025Payload length too large!" |
| echo "3005Is this message formed properly?" \| nc localhost 11044 | "3005Is this message formed properly?" | "5026Payload length inaccurate!" |

## Client
The client program, due to being developed after the server has been tested
and shown to be working, will be tested with the server program itself
instead of a separate application. Instead of providing a command as the first
column, the well-formed message containing the question will be used instead.
The second column will be contain the well-formed response message from the 
server, and the last column will contain the extracted response that was
contained within the payload of the message.

| Question | Response Message | Response Payload |
| -------- | ---------------- | ---------------- |
| "3026Is it going to rain today?" | "4018You may rely on it" | "You may rely on it" |
| "3020Should I learn Lisp?" | "4015Without a doubt" | "Without a doubt" |
| "3023Is UNA better than UAH?" | "4013It is certain" | "It is certain" |

# Solution Plan

## Server
1. Open a socket: Using the BSD socket API, the "socket" function will be called to generate a file descriptor used as an endpoint for communication over the network.
2. Bind a port: Using the file descriptor given in step 1, the specified port will be bound by the socket to interface with the network.
3. Listen: The program will begin listening over the socket for incoming connections.
4. Loop until SIGINT is raised: Using a "sig_atomic_t" variable and the "handle" function, the program will loop repeatedly until SIGINT is raised.
5. Accept a connection: The server will wait until a client attempts to connect over the bound port, at which point it will accept the connection and generate a new file descriptor for communication with the connected client.
6. Receive a message with type "10": The server will receive a message using the "recv" function from the client. If the message is not of the right type or does not conform to the magic 8 ball protocol, the server will respond with a message of type "50" to cease communication.
7. Respond with a message of type "20": The server will respond to the client with a message of type "20" using the "send" function. This message contains some unimportant text, such as a greeting. This message must be properly encoded.
8. Receive a message with type "30": The server will receive a message from the client of type "30" using the "recv" function. This message contains a question in its payload, but it does not need to be extracted from the message. Conformity to the magic 8 ball needs to be verified, along with the type of the message; if an error occurs, respond with a message of type "50" and cease communication.
9. Randomly generate and send answer to question: Following the question message being received, the server should pseudo-randomly generate a question, and encode it into a valid messsage. The message will then be sent to the client and communication will be ceased.
10. Following SIGINT being raised, exit gracefully: After the signal SIGINT has been raised, exit the main loop of accepting a connection, sending, and receiving. Close the main socket generated initially and exit gracefully.

## Client
1. Assert that command-line input is correct and get server address: Verify that the hostname passed as a command-line argument is valid using the "gethostbyname" function.
2. Open a socket: Using the BSD socket API, call the "socket" function to generate a file descriptor that will be used for connecting to the server.
3. Active open: Using the "connect" function, actively connect to the server whose address is specified by the "gethostbyname" function.
4. Send initial message of type "10": This is the initial message sent to the server. For the purposes of this program, this will be a greeting to the server. The message needs to be properly encoded.
5. Receive message of type "20" from the server: Using the "recv" function, a message of type "20" must be received from the server. The payload of the message is not important and does not have to be parsed. The type of the message and conformity to the magic 8 ball protocol must be verified; if either are incorrect, respond with a properly encoded message of type "50" to cease communication with the server.
6. Send question message with type "30": Encode the desired question into a message that conforms to the magic 8 ball protocol, and send it to the server using the "send" function.
7. Receive response to question via message of type "40": Receive the next message from the server using the "recv" function. This message must be verified (both the type and sanity as specified in the magic 8 ball protocol) and the payload must be extracted from the message. If an error occurs, send a message back to the server with type "50" (although it may not be received).
8. Write answer to screen: Following the extraction of the payload from the previous message, write the buffer containing the payload to stdout so that it may be viewed by the end user.
